---
description: Analysis of data flow between components in dual GPU optimization system for monitoring resource usage and managing model execution
globs: **/dualgpuopt/**/*.py,**/dual_gpu_optimizer/**/*.py,**/examples/**/*.py
alwaysApply: false
---


# data-flow-architecture

## Core Data Flow Components

### GPU Telemetry Pipeline
- GPU metrics collected via `TelemetryService` (telemetry.py)
- Metrics include utilization, memory, temperature, power draw
- 60-second rolling history maintained per GPU using circular buffer
- Metrics published to event bus for real-time monitoring
- Alert levels (Emergency, Critical, Warning) based on thresholds

### Memory Management Flow 
- `MemoryProfiler` tracks per-GPU memory patterns (profiler.py)
- Leak detection using 20-sample sliding window analysis
- Memory growth rates calculated and correlated with token counts
- Anomaly alerts generated for spikes (>10%) and sustained leaks (>5%)
- Memory reset commands flow through `vram_reset.py`

### Model Execution Pipeline
- Model parameters and tensor splits calculated in `optimizer.py`
- Layer distribution optimized across GPUs based on relative memory capacity
- Commands generated for model frameworks (llama.cpp, vLLM)
- Process output streamed through `ProcessMonitor` for resource tracking
- Model state changes published through event bus

### Alert and Notification Flow
- GPU alerts originate from telemetry service based on thresholds
- Memory alerts generated by profiler based on growth patterns
- Alerts aggregated and deduplicated in error handler
- Status updates propagated to UI through event bus
- System tray notifications for critical alerts

### Configuration Data Flow
- Model presets loaded from disk through config service
- GPU settings stored and retrieved via state service 
- User preferences persisted through settings service
- Theme and UI configurations managed by theme service
- All configuration changes broadcast via event bus

### Metrics Collection Flow
- Real-time GPU metrics collected by telemetry service
- Memory statistics gathered by memory profiler
- Process metrics monitored by launcher
- Metrics aggregated for visualization in dashboard
- Historical data maintained in rolling buffers

$END$